/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package udp.broadcast.reproducer;

import io.vertx.core.AsyncResult;
import io.vertx.core.Handler;
import io.vertx.core.Vertx;
import io.vertx.core.datagram.DatagramSocket;
import io.vertx.core.datagram.DatagramSocketOptions;
import io.vertx.junit5.Checkpoint;
import io.vertx.junit5.Timeout;
import io.vertx.junit5.VertxExtension;
import io.vertx.junit5.VertxTestContext;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(VertxExtension.class)
class AppTest {
	@Test
	@Timeout(4000)
	public void testUdpListensNullInterface(Vertx vertx, VertxTestContext context) {
		vertx.createDatagramSocket()
				.listen(6112, "0.0.0.0", context.succeeding(res -> {
					res.listenMulticastGroup("231.0.0.1", context.succeeding());
				}));
	}


	@ParameterizedTest()
	@ValueSource(longs = {0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 920L, 960L, 1000L})
	void testUdpBroadcastResponse(long delay) throws InterruptedException {
		Vertx vertx = Vertx.vertx();
		VertxTestContext context = new VertxTestContext();
		// On Travis, UDP broadcast is disabled!
		if (System.getenv().containsKey("TRAVIS")) {
			context.verify(() -> {
				fail("Multicast does not work on Travis");
			});
			return;
		}

		System.setProperty("java.net.preferIPv4Stack", "true");
		Broadcaster verticle = Broadcaster.create();
		Checkpoint checkpoint = context.checkpoint(1);

		vertx.deployVerticle(verticle, context.succeeding(then -> {
			vertx.createDatagramSocket(new DatagramSocketOptions()
					.setReuseAddress(true)
					.setReusePort(true))
					.listen(verticle.getMulticastPort() + 1, "0.0.0.0", context.succeeding(socket -> {
						context.verify(() -> {
							assertTrue(verticle.isListening().get(), "at this point, BroadcasterImpl thinks it has joined the multicast group");
							socket.handler(packet -> {
								context.verify(() -> {
									String packetData = packet.data().toString();
									assertEquals(verticle.getResponse(), packetData);
									checkpoint.flag();
								});
							});

							Handler<AsyncResult<DatagramSocket>> sendSucceeds = context.succeeding();
							if (delay == 0L) {
								socket.send(verticle.getRequest(), verticle.getMulticastPort(), verticle.getMulticastAddress(), sendSucceeds);
							} else {
								vertx.setTimer(delay, v -> socket.send(verticle.getRequest(), verticle.getMulticastPort(), verticle.getMulticastAddress(), sendSucceeds));
							}
						});
					}));
		}));

		context.awaitCompletion(4, TimeUnit.SECONDS);
		vertx.close(context.succeeding());
	}

	@ParameterizedTest()
	@Timeout(4050)
	@ValueSource(longs = {0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 0L, 920L, 960L, 1000L})
	void testUdpBroadcastResponseInjected(long delay, Vertx vertx, VertxTestContext context) throws InterruptedException {
		// On Travis, UDP broadcast is disabled!
		if (System.getenv().containsKey("TRAVIS")) {
			context.verify(() -> {
				fail("Multicast does not work on Travis");
			});
			return;
		}

		System.setProperty("java.net.preferIPv4Stack", "true");
		Broadcaster verticle = Broadcaster.create();
		Checkpoint checkpoint = context.checkpoint(1);

		vertx.deployVerticle(verticle, context.succeeding(then -> {
			vertx.createDatagramSocket(new DatagramSocketOptions()
					.setReuseAddress(true)
					.setReusePort(true))
					.listen(6110, "0.0.0.0", context.succeeding(socket -> {
						context.verify(() -> {
							assertTrue(verticle.isListening().get(), "at this point, BroadcasterImpl thinks it has joined the multicast group");
							socket.handler(packet -> {
								context.verify(() -> {
									String packetData = packet.data().toString();
									assertEquals(verticle.getResponse(), packetData);
									checkpoint.flag();
								});
							});

							Handler<AsyncResult<DatagramSocket>> sendSucceeds = context.succeeding();
							if (delay == 0L) {
								socket.send(verticle.getRequest(), verticle.getMulticastPort(), verticle.getMulticastAddress(), sendSucceeds);
							} else {
								vertx.setTimer(delay, v -> socket.send(verticle.getRequest(), verticle.getMulticastPort(), verticle.getMulticastAddress(), sendSucceeds));
							}
						});
					}));
		}));

		context.awaitCompletion(4, TimeUnit.SECONDS);
	}
}
